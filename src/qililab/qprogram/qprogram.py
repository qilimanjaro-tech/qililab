# Copyright 2023 Qilimanjaro Quantum Tech
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from copy import deepcopy
from typing import TYPE_CHECKING, Sequence, overload

import numpy as np

from qililab.core.variables import Domain, Variable, requires_domain
from qililab.qprogram.blocks.block import Block
from qililab.qprogram.blocks.for_loop import ForLoop
from qililab.qprogram.blocks.parallel import Parallel
from qililab.qprogram.calibration import Calibration
from qililab.qprogram.crosstalk_matrix import CrosstalkMatrix, FluxVector
from qililab.qprogram.operations import (
    Acquire,
    AcquireWithCalibratedWeights,
    Measure,
    MeasureReset,
    MeasureResetCalibrated,
    MeasureWithCalibratedWaveform,
    MeasureWithCalibratedWaveformWeights,
    MeasureWithCalibratedWeights,
    Operation,
    Play,
    PlayWithCalibratedWaveform,
    ResetPhase,
    SetFrequency,
    SetGain,
    SetMarkers,
    SetOffset,
    SetPhase,
    SetTrigger,
    Sync,
    Wait,
    WaitTrigger,
)
from qililab.qprogram.structured_program import StructuredProgram, VariableInfo
from qililab.waveforms import Arbitrary, FlatTop, IQPair, IQWaveform, Square, Waveform
from qililab.yaml import yaml

if TYPE_CHECKING:
    from qililab.extra.quantum_machines.qprogram.quantum_machines_compiler import QuantumMachinesCompilationOutput
    from qililab.qprogram.qblox_compiler import QbloxCompilationOutput
    from qililab.qprogram.qdac_compiler import QdacCompilationOutput


class QProgramCompilationOutput:
    """Class representing the output information generated by qprogram compiler."""

    def __init__(
        self,
        qblox: "QbloxCompilationOutput | None" = None,
        qdac: "QdacCompilationOutput | None" = None,
        quantum_machines: "QuantumMachinesCompilationOutput | None" = None,
    ):
        self.qblox = qblox
        self.qdac = qdac
        self.quantum_machines = quantum_machines


class CrosstalkElements:
    """_summary_"""

    def __init__(self, crosstalk: CrosstalkMatrix):
        self.crosstalk = crosstalk

        self.element_list: dict[int, tuple[FluxVector, list[int]]] = {}

        self.element_group: dict[str, list[int]] = {}
        self.element: dict[str, list[Play | SetOffset | SetGain]] = {}
        self.flux_vector: dict[str, FluxVector] = {}
        self.flux_vector_bus: dict[str, list[str]] = {}

    def add_element(self, element: Play | SetOffset | SetGain, iteration: int):
        """Restart flux vector if the bus already has been used for the specific operation_class

        Args:
            operation_class (_type_): _description_
            bus (_type_): _description_
        """

        operation = str(element.__class__)
        self.element[operation].append(element)
        self.element_group[operation].append(iteration)
        self.flux_vector_bus[operation].append(element.bus)

        for ii in self.element_group[operation]:
            self.element_list[ii] = (self.flux_vector[operation], self.element_group[operation])

    def check_flux_vector(self, element: Play | SetOffset | SetGain):
        """_summary_

        Args:
            element (Play | SetOffset | SetGain): _description_
        """
        operation = str(element.__class__)
        if operation not in self.flux_vector_bus.keys() or element.bus in self.flux_vector_bus[operation]:
            self.restart_flux_vector(operation)

    def restart_flux_vector(self, operation: str | None = None):
        """_summary_

        Args:
            element (Play | SetOffset | SetGain): _description_
        """

        if operation is not None:
            self.element[operation] = []
            self.element_group[operation] = []
            self.flux_vector_bus[operation] = []
            self.flux_vector[operation] = FluxVector()
            self.flux_vector[operation].set_crosstalk(self.crosstalk)
        else:
            for operation in self.element_group.keys():
                self.element[operation] = []
                self.element_group[operation] = []
                self.flux_vector_bus[operation] = []
                self.flux_vector[operation] = FluxVector()
                self.flux_vector[operation].set_crosstalk(self.crosstalk)


@yaml.register_class
class QProgram(StructuredProgram):
    """QProgram is a hardware-agnostic pulse-level programming interface for describing quantum programs.

    This class provides an interface for building quantum programs,
    including defining operations, managing variables, and handling blocks.
    It contains methods for creating, manipulating and controlling
    the execution flow of quantum operations within a program.

    Examples:

        The following example illustrates how to define a Rabi sequence using QProgram.

        .. code-block:: python3

            from qililab import QProgram, Domain, IQWaveform, Square

            qp = QProgram()

            # Pulse used for changing the state of qubit
            control_wf = IQDRAG(amplitude=1.0, duration=40, num_sigmas=4.0, drag_correction=-2.5)

            # Pulse used for exciting the resonator for readout
            readout_wf = IQWaveform(I=Square(amplitude=1.0, duration=400), Q=Square(amplitude=0.0, duration=400))

            # Weights used during integration
            weights = IQWaveform(I=Square(amplitude=1.0, duration=2000), Q=Square(amplitude=1.0, duration=2000))

            # Declare a variable
            gain = qp.variable(label="gain", domain=Domain.Voltage)

            # Loop the variable's value over the range [0.0, 1.0]
            with qp.for_loop(variable=gain, start=0.0, stop=1.0, step=0.01):
                # Change the gain output of the drive_bus
                qp.set_gain(bus="drive_bus", gain=gain)

                # Play the control pulse
                qp.play(bus="drive_bus", waveform=control_wf)

                # Sync the buses
                qp.sync()

                # Measure
                qp.measure(bus="readout_bus", waveform=readout_wf, weights=weights)

    """

    def __init__(self) -> None:
        super().__init__()
        self.qblox = self._QbloxInterface(self)
        self.quantum_machines = self._QuantumMachinesInterface(self)
        self.qdac = self._QdacInterface(self)

    def __str__(self) -> str:
        def traverse(block: Block):
            string_elements = []
            for element in block.elements:
                string_elements.append(f"{type(element).__name__}:\n")
                for attr_name in vars(element):
                    # ignore uuid, variables. elements, waveforms and weights are handled separately
                    if attr_name in ("_uuid", "variable", "elements", "waveform", "weights"):
                        continue

                    attr_value = getattr(element, attr_name)
                    # Handle UUID checking and append to string_elements
                    if "UUID" not in str(attr_value):
                        string_elements.append(f"\t{attr_name}: {attr_value}\n")
                    else:
                        string_elements.append(f"\t{attr_name}: None\n")  # pragma: no cover

                if isinstance(element, Block):
                    # handle blocks
                    for string_element in traverse(element):
                        string_elements.append(f"\t{string_element}")

                # if not a block, it is assumed that element is type Operation
                if hasattr(element, "waveform"):
                    waveform_string = (
                        [f"\tWaveform {type(element.waveform).__name__}:\n"]
                        + [f"\t\t{array_line}\n" for array_line in str(element.waveform.envelope()).split("\n")]
                        if isinstance(element.waveform, Waveform)
                        else [f"\tWaveform I {type(element.waveform.get_I()).__name__}:\n"]
                        + [f"\t\t{array_line}\n" for array_line in str(element.waveform.get_I().envelope()).split("\n")]
                        + [f"\tWaveform Q {type(element.waveform.get_Q()).__name__}):\n"]
                        + [f"\t\t{array_line}\n" for array_line in str(element.waveform.get_Q().envelope()).split("\n")]
                    )
                    string_elements.extend(waveform_string)

                if hasattr(element, "weights"):
                    string_elements.append(f"\tWeights I {type(element.weights.get_I()).__name__}:\n")
                    string_elements.extend(
                        [
                            f"\t\t{array_element}\n"
                            for array_element in str(element.weights.get_I().envelope()).split("\n")
                        ]
                    )
                    string_elements.append(f"\tWeights Q {type(element.weights.get_Q()).__name__}:\n")
                    string_elements.extend(
                        [
                            f"\t\t{array_element}\n"
                            for array_element in str(element.weights.get_Q().envelope()).split("\n")
                        ]
                    )

            return string_elements

        return "".join(traverse(self._body))

    def has_calibrated_waveforms_or_weights(self) -> bool:
        """Checks if QProgram has named waveforms or weights. These need to be mapped before compiling to hardware-native code.

        Returns:
            bool: True, if QProgram has waveforms or weights that need to be mapped from calibration.
        """

        def traverse(block: Block):
            for element in block.elements:
                if isinstance(element, Block):
                    if traverse(element):
                        return True
                elif isinstance(
                    element,
                    (
                        PlayWithCalibratedWaveform,
                        AcquireWithCalibratedWeights,
                        MeasureWithCalibratedWaveform,
                        MeasureWithCalibratedWeights,
                        MeasureWithCalibratedWaveformWeights,
                        MeasureResetCalibrated,
                    ),
                ):
                    return True
            return False

        return traverse(self.body)

    def with_bus_mapping(self, bus_mapping: dict[str, str]) -> "QProgram":
        """Returns a copy of the QProgram with bus mappings applied.

        Args:
            bus_mapping (dict[str, str]): A dictionary mapping old bus names to new bus names.

        Returns:
            QProgram: A new instance of QProgram with updated bus names.
        """

        def traverse(block: Block):
            for index, element in enumerate(block.elements):
                if isinstance(element, Block):
                    traverse(element)
                elif isinstance(element, (MeasureReset, MeasureResetCalibrated)):
                    bus = getattr(element, "bus")
                    control_bus = getattr(element, "control_bus")
                    if isinstance(bus, str) and bus in bus_mapping:
                        setattr(block.elements[index], "bus", bus_mapping[bus])
                    if isinstance(control_bus, str) and control_bus in bus_mapping:
                        setattr(block.elements[index], "control_bus", bus_mapping[control_bus])
                    new_latch_enabled = []
                    for bus in copied_qprogram.qblox.latch_enabled:
                        if bus in bus_mapping:
                            new_latch_enabled.append(bus_mapping[bus])
                        else:
                            new_latch_enabled.append(bus)
                    copied_qprogram.qblox.latch_enabled = new_latch_enabled

                    new_trigger_network_required = {}
                    for bus, value in copied_qprogram.qblox.trigger_network_required.items():
                        if bus in bus_mapping:
                            new_trigger_network_required[bus_mapping[bus]] = value
                        else:
                            new_trigger_network_required[bus] = value
                    copied_qprogram.qblox.trigger_network_required = new_trigger_network_required
                elif hasattr(element, "bus"):
                    bus = getattr(element, "bus")
                    if isinstance(bus, str) and bus in bus_mapping:
                        setattr(block.elements[index], "bus", bus_mapping[bus])
                elif hasattr(element, "buses"):
                    buses = getattr(element, "buses")
                    if isinstance(buses, list):
                        setattr(
                            block.elements[index],
                            "buses",
                            [bus_mapping[bus] if bus in bus_mapping else bus for bus in buses],
                        )

        # Copy qprogram so the original remain unaffected
        copied_qprogram = deepcopy(self)

        # Recursively traverse qprogram applying the bus mapping
        traverse(copied_qprogram.body)

        # Apply the mapping to buses property
        for bus in list(copied_qprogram.buses):
            if bus in bus_mapping:
                copied_qprogram.buses.remove(bus)
                copied_qprogram.buses.add(bus_mapping[bus])

        return copied_qprogram

    def with_calibration(self, calibration: Calibration):
        """Apply calibration to the operations within the QProgram.

        This method traverses the elements of the QProgram, replacing any
        named operations with the corresponding calibrated waveforms specified
        in the given Calibration instance.

        Args:
            calibration (Calibration): The calibration data to apply to the operations.

        Returns:
            QProgram: A new instance of QProgram with calibrated operations.
        """
        buses_to_add: set[str] = set()
        latch_to_add: list[str] = []
        trigger_network_to_add: dict[str, int] = {}

        def traverse(block: Block):
            for index, element in enumerate(block.elements):
                if isinstance(element, Block):
                    traverse(element)
                elif isinstance(element, PlayWithCalibratedWaveform) and calibration.has_waveform(
                    bus=element.bus, name=element.waveform
                ):
                    waveform = calibration.get_waveform(bus=element.bus, name=element.waveform)
                    play_operation = Play(bus=element.bus, waveform=waveform, wait_time=element.wait_time)
                    block.elements[index] = play_operation
                elif isinstance(element, AcquireWithCalibratedWeights) and calibration.has_weights(
                    bus=element.bus, name=element.weights
                ):
                    weights = calibration.get_weights(bus=element.bus, name=element.weights)
                    acquire_operation = Acquire(bus=element.bus, weights=weights, save_adc=element.save_adc)
                    block.elements[index] = acquire_operation
                elif isinstance(element, MeasureWithCalibratedWaveform) and calibration.has_waveform(
                    bus=element.bus, name=element.waveform
                ):
                    waveform = calibration.get_waveform(bus=element.bus, name=element.waveform)
                    measure_operation = Measure(
                        bus=element.bus,
                        waveform=waveform,
                        weights=element.weights,
                        demodulation=element.demodulation,
                        save_adc=element.save_adc,
                    )
                    block.elements[index] = measure_operation
                elif isinstance(element, MeasureWithCalibratedWeights) and calibration.has_weights(
                    bus=element.bus, name=element.weights
                ):
                    weights = calibration.get_weights(bus=element.bus, name=element.weights)
                    measure_operation = Measure(
                        bus=element.bus,
                        waveform=element.waveform,
                        weights=weights,
                        demodulation=element.demodulation,
                        save_adc=element.save_adc,
                    )
                    block.elements[index] = measure_operation
                elif (
                    isinstance(element, MeasureWithCalibratedWaveformWeights)
                    and calibration.has_waveform(bus=element.bus, name=element.waveform)
                    and calibration.has_weights(bus=element.bus, name=element.weights)
                ):
                    waveform = calibration.get_waveform(bus=element.bus, name=element.waveform)
                    weights = calibration.get_weights(bus=element.bus, name=element.weights)
                    measure_operation = Measure(
                        bus=element.bus,
                        waveform=waveform,
                        weights=weights,
                        demodulation=element.demodulation,
                        save_adc=element.save_adc,
                    )
                    block.elements[index] = measure_operation
                elif (
                    isinstance(element, MeasureResetCalibrated)
                    and calibration.has_waveform(bus=element.bus, name=element.waveform)
                    and calibration.has_weights(bus=element.bus, name=element.weights)
                    and calibration.has_waveform(bus=element.control_bus, name=element.reset_pulse)
                ):
                    waveform = calibration.get_waveform(bus=element.bus, name=element.waveform)
                    weights = calibration.get_weights(bus=element.bus, name=element.weights)
                    reset_pulse = calibration.get_waveform(bus=element.control_bus, name=element.reset_pulse)
                    measure_reset_operation = MeasureReset(
                        bus=element.bus,
                        waveform=waveform,
                        weights=weights,
                        control_bus=element.control_bus,
                        reset_pulse=reset_pulse,
                        trigger_address=element.trigger_address,
                        save_adc=element.save_adc,
                    )
                    block.elements[index] = measure_reset_operation
                    buses_to_add.add(element.control_bus)
                    latch_to_add.append(element.control_bus)
                    trigger_network_to_add[element.bus] = element.trigger_address

                if hasattr(element, "bus"):
                    bus = getattr(element, "bus")
                    buses_to_add.add(bus)

        copied_qprogram = deepcopy(self)
        traverse(copied_qprogram.body)

        if buses_to_add:
            copied_qprogram._buses.update(buses_to_add)

        if latch_to_add:
            copied_qprogram.qblox.latch_enabled.extend(latch_to_add)

        if trigger_network_to_add:
            copied_qprogram.qblox.trigger_network_required.update(trigger_network_to_add)

        return copied_qprogram

    def with_crosstalk(self, crosstalk: CrosstalkMatrix):
        """Apply crosstalk compensation to the qprogram flux buses.

        This method traverses the elements of the QProgram, replacing any
        Play or Offset instances by the compensated envelope or offset for
        all flux buses.

        Args:
            crosstalk (CrosstalkMatrix): Crosstalk matrix class.

        Returns:
            QProgram: A new instance of QProgram with calibrated crosstalk.
        """
        self._bus_variable_map: dict[tuple[Variable, str], Variable] = {}
        self._block_variables: dict[Variable, list[Variable]] = {}
        self._parallel_loops: dict[Variable, list[ForLoop]] = {}
        self._active_loops: list[ForLoop] = []
        self._loop_depths: list[int] = []

        def traverse(block: Block, variables: dict[Variable, VariableInfo]):
            """
            Traverse through all block elements and modify ForLoop, Parallel, Play, SetOffset and SetGain.
            """
            crosstalk_elements = CrosstalkElements(crosstalk)
            loop_idx = self._loop_depths[-1] + 1 if self._loop_depths else 0

            for i, element in enumerate(block.elements):
                if isinstance(element, (Play, SetOffset, SetGain)) and element.bus in crosstalk.matrix.keys():
                    crosstalk_elements.check_flux_vector(element)

                    crosstalk_elements.flux_vector[str(element.__class__)] = handle_flux_vector(
                        flux_vector=crosstalk_elements.flux_vector[str(element.__class__)],
                        element=element,
                    )
                    crosstalk_elements.add_element(element, i)
                if isinstance(element, (Wait, Acquire, Measure, MeasureReset)) or (
                    isinstance(element, Play) and element.bus not in crosstalk.matrix.keys()
                ):
                    crosstalk_elements.restart_flux_vector()

                if isinstance(element, Block):
                    crosstalk_elements.restart_flux_vector()
                    variable_list = None
                    if isinstance(element, ForLoop):
                        variable_list = [element.variable]
                        self._active_loops.append(element)
                        self._loop_depths.append(loop_idx)
                    if isinstance(element, Parallel) and all(isinstance(loop, ForLoop) for loop in element.loops):
                        variable_list = [loop.variable for loop in element.loops]
                        for loop in element.loops:
                            self._active_loops.append(loop)  # type: ignore [arg-type]
                            self._loop_depths.append(loop_idx)

                    traverse(element, variables)

                    if variable_list is not None and any(
                        variable in self._parallel_loops for variable in variable_list
                    ):
                        loop_list: list[ForLoop] = []
                        for variable in (v for v in variable_list if v in self._parallel_loops):
                            valid_loops = [
                                loop
                                for loop in self._parallel_loops[variable]
                                if loop.variable in self._block_variables[variable]
                            ]
                            loop_list.extend(valid_loops)

                            for new_variable in self._block_variables[variable]:
                                variables[new_variable] = VariableInfo()
                            self._block_variables[variable] = []
                        parallel_loop = Parallel(loops=loop_list)
                        parallel_loop.elements = element.elements
                        block.elements[i] = parallel_loop
                        self._active_loops = self._active_loops[:-1]
                        self._loop_depths = self._loop_depths[:-1]

            block = handle_crosstalk_element(block=block, crosstalk_elements=crosstalk_elements)

        def handle_flux_vector(flux_vector: FluxVector, element: Play | SetGain | SetOffset):
            """
            Generates the flux vector based on the element parameters, variables and loops.
            """
            if isinstance(element, Play):
                if isinstance(element.waveform, Waveform):
                    waveform = element.waveform.I if isinstance(element.waveform, IQPair) else element.waveform
                    envelope = waveform.envelope()
            elif isinstance(element, SetOffset):
                envelope = element.offset_path0  # type: ignore [assignment]
            elif isinstance(element, SetGain):
                envelope = element.gain  # type: ignore [assignment]

            if isinstance(envelope, Variable):
                variable_loop = next((loop for loop in self._active_loops[::-1] if loop.variable == envelope), None)
                if variable_loop:
                    envelope = (
                        np.arange(variable_loop.start, variable_loop.stop, variable_loop.step)
                        if isinstance(variable_loop, ForLoop)
                        else variable_loop
                    )
                    if not envelope.tolist():
                        raise ValueError(
                            "Parameters of the ForLoop not assigned correctly. Please check start, stop and step values."
                        )
            flux_vector[element.bus] = envelope
            return flux_vector

        def handle_crosstalk_element(block: Block, crosstalk_elements: CrosstalkElements):
            """
            Modifies the block for crosstalk compensation.
            By modifying the voltage of the existing elements and adding new ones based on the compensated bias.
            """
            elements: dict[int, Play | SetGain | SetOffset] = {}
            additional_elements = 0

            handle_crosstalk_loop(block.elements, crosstalk_elements)

            for ii, element_idx in enumerate(crosstalk_elements.element_list.keys()):
                elements[element_idx] = block.elements.pop(element_idx - ii)  # type: ignore [assignment]

            for ii, element_idx in enumerate(crosstalk_elements.element_list.keys()):
                flux_vector, element_group = crosstalk_elements.element_list[element_idx]
                element = elements[element_idx]
                element_group_bus = [elements[group_id].bus for group_id in element_group]

                for bus in flux_vector.bias_vector.keys():
                    if bus not in element_group_bus or element.bus == bus:
                        operation = handle_element(
                            element, bus, flux_vector, element_group, element_group_bus, elements
                        )
                        block.elements.insert(element_idx + additional_elements, operation)
                        if bus not in element_group_bus:
                            additional_elements += 1
            return block

        def handle_element(
            element: SetOffset | SetGain | Play,
            bus: str,
            flux_vector: FluxVector,
            element_group: list[int],
            element_group_bus: list[str],
            elements: dict[int, Play | SetGain | SetOffset],
        ):
            """
            Modifies SetOffset, SetGain or Play based on its element type.
            """
            bias_vector = flux_vector.bias_vector[bus]
            if all(isinstance(elements[element], (SetOffset, SetGain)) for element in element_group):
                _, variable_list = handle_flux_v_flux(elements, flux_vector, element_group, element_group_bus)

            if isinstance(element, SetOffset):
                operation = handle_offset(element, bus, bias_vector, element_group, variable_list, elements)  # type: ignore [arg-type]
            if isinstance(element, SetGain):
                operation = handle_gain(element, bus, bias_vector, element_group, variable_list, elements)  # type: ignore [arg-type]
            if isinstance(element, Play):
                operation = handle_play(bus, bias_vector, element_group, elements)  # type: ignore [arg-type]
            return operation

        def handle_offset(
            element: SetOffset,
            bus: str,
            bias_vector: float | list[float] | np.ndarray,
            element_group: list[int],
            variable_list: list[Variable],
            elements: dict[int, SetOffset],
        ):
            """
            Modifies SetOffset by compensating the bias vector or modifying the variables.
            """
            if isinstance(bias_vector, np.ndarray):
                variable = (
                    element.offset_path0
                    if isinstance(element.offset_path0, Variable)
                    else next(
                        (
                            elements[element_id].offset_path0  # type: ignore [misc]
                            for element_id in element_group
                            if isinstance(elements[element_id].offset_path0, Variable)
                        ),
                        None,  # type: ignore [arg-type]
                    )
                )
                dict_variable = self._bus_variable_map[variable, bus]

                if len(variable_list) > 1 and variable in variable_list:
                    for var in variable_list:
                        if var.label != variable.label:
                            dict_variable += self._bus_variable_map[var, bus]
                            self._block_variables[var].append(self._bus_variable_map[var, bus])

                offset = SetOffset(bus, dict_variable)
                self._block_variables[variable].append(dict_variable)
            elif isinstance(bias_vector, float):
                offset = SetOffset(bus, bias_vector)

            return offset

        def handle_gain(
            element: SetGain,
            bus: str,
            bias_vector: float | list[float] | np.ndarray,
            element_group: list[int],
            variable_list: list[Variable],
            elements: dict[int, SetGain],
        ):
            """
            Modifies SetGain by compensating the bias vector or modifying the variables.
            """
            if isinstance(bias_vector, np.ndarray):
                variable = (
                    element.gain
                    if isinstance(element.gain, Variable)
                    else next(
                        (
                            elements[element_id].gain  # type: ignore [misc]
                            for element_id in element_group
                            if isinstance(elements[element_id].gain, Variable)
                        ),
                        None,  # type: ignore [arg-type]
                    )
                )
                dict_variable = self._bus_variable_map[variable, bus]

                if len(variable_list) > 1 and variable in variable_list:
                    for var in variable_list:
                        if var.label != variable.label:
                            dict_variable += self._bus_variable_map[var, bus]
                            self._block_variables[var].append(self._bus_variable_map[var, bus])

                gain = SetGain(bus, dict_variable)
                self._block_variables[variable].append(dict_variable)
            elif isinstance(bias_vector, float):
                gain = SetGain(bus, bias_vector)
            return gain

        def handle_play(
            bus: str,
            bias_vector: float | list[float] | np.ndarray,
            element_group: list[int],
            elements: dict[int, Play],
        ):
            """
            Modifies Play creating a compensated Arbitrary pulse.
            For Square and FlatTop pulses uses the same type instead of an Arbitrary pulse.
            """
            play_elements = [elements[element] for element in element_group if isinstance(elements[element], Play)]
            if len({(play.dwell, play.delay, play.repetitions, play.wait_time) for play in play_elements}) > 1:
                raise ValueError("Play elements must be the same for the same play pulse.")
            dwell, delay, repetitions, stepped, wait_time = (
                play_elements[0].dwell,
                play_elements[0].delay,
                play_elements[0].repetitions,
                play_elements[0].stepped,
                play_elements[0].wait_time,
            )

            waveforms: Sequence[Square | FlatTop] = [elements[element].waveform for element in element_group]  # type: ignore [misc]
            if any(isinstance(element, SetGain) for element in elements.values()):
                # Normalizes every time gain is used
                bias_vector = bias_vector / np.max(bias_vector)
            if all(isinstance(wf, Square) for wf in waveforms):
                waveform = Square(amplitude=np.max(bias_vector), duration=waveforms[0].duration)
            elif all(isinstance(wf, FlatTop) for wf in waveforms):
                if len({(wf.duration, wf.smooth_duration, wf.buffer) for wf in waveforms}) > 1:  # type: ignore [union-attr]
                    raise ValueError("FlatTop parameters must be the same for all compensated pulses.")
                waveform = FlatTop(
                    amplitude=np.max(bias_vector),
                    duration=waveforms[0].duration,
                    smooth_duration=waveforms[0].smooth_duration,  # type: ignore [union-attr]
                    buffer=waveforms[0].buffer,  # type: ignore [union-attr]
                )
            else:
                if not isinstance(bias_vector, np.ndarray):
                    raise ValueError("Arbitrary samples must be an array.")
                waveform = Arbitrary(bias_vector)

            play = Play(
                bus=bus,
                waveform=waveform,
                dwell=dwell,
                delay=delay,
                repetitions=repetitions,
                stepped=stepped,
                wait_time=wait_time,
            )
            return play

        def handle_crosstalk_loop(elements_block: list[Block | Operation], crosstalk_elements: CrosstalkElements):
            """
            Generates necessary information to process for loops into parallel loops for compensating variables.
            In form of ForLoops lists inside self._parallel_loops.
            """
            elements: dict[int, Play | SetGain | SetOffset] = {}

            for element_idx in crosstalk_elements.element_list.keys():
                elements[element_idx] = elements_block[element_idx]  # type: ignore [assignment]

            for element_idx in crosstalk_elements.element_list.keys():
                flux_vector, element_group = crosstalk_elements.element_list[element_idx]
                element_group_bus = [elements[group_id].bus for group_id in element_group]
                element = elements[element_idx]
                variable = get_element_variable(element)

                if variable is not None:
                    for_loop_list = []
                    list_fluxes, _ = handle_flux_v_flux(elements, flux_vector, element_group, element_group_bus)

                    if len(list_fluxes) > 1:
                        for bus in crosstalk.matrix.keys():
                            bias_vector = list_fluxes[element.bus].bias_vector[bus]
                            for_loop_list.append(make_for_loop(variable, bus, bias_vector))
                    else:
                        for bus in crosstalk.matrix.keys():
                            bias_vector = flux_vector.bias_vector[bus]
                            for_loop_list.append(make_for_loop(variable, bus, bias_vector))

                    self._parallel_loops[variable] = for_loop_list

                    if variable not in self._block_variables:
                        self._block_variables[variable] = []

        def handle_flux_v_flux(
            elements: dict[int, Play | SetGain | SetOffset], flux_vector: FluxVector, element_group, element_group_bus
        ):
            """
            Function to get multiple flux vectors by decomposing the flux_vector for each loop that contains a variable.
            This is for structures where multiple ForLoops are executed one inside the other (such as flux vs flux).
            """
            bus_list = []
            variable_list = []
            used_loop_indices = set()
            for ii, element_idx in enumerate(element_group):
                element = elements[element_idx]
                variable = get_element_variable(element)
                if variable is not None and variable in [loop.variable for loop in self._active_loops]:
                    loop_idx = next(
                        (idx for loop, idx in zip(self._active_loops, self._loop_depths) if loop.variable is variable),
                        None,
                    )
                    if loop_idx is not None and loop_idx not in used_loop_indices:
                        used_loop_indices.add(loop_idx)
                        bus_list.append(element_group_bus[ii])
                        variable_list.append(variable)
            return flux_vector.get_decomposed_vector(bus_list), variable_list

        def get_element_variable(element: Play | SetGain | SetOffset) -> Variable | None:
            """
            Returns variable for SetGain and SetOffset elements.
            """
            if isinstance(element, SetGain) and isinstance(element.gain, Variable):
                return element.gain
            if isinstance(element, SetOffset) and isinstance(element.offset_path0, Variable):
                return element.offset_path0
            return None

        def make_for_loop(variable: Variable, bus: str, bias_vector: Sequence[float]) -> ForLoop:
            """
            Creates a for loop for a given variable with the bus and bias vector.
            """
            if (variable, bus) not in self._bus_variable_map:
                self._bus_variable_map[variable, bus] = Variable(label=f"{bus}_{variable}", domain=Domain.Voltage)

            start, stop = bias_vector[0], bias_vector[-1]
            step = bias_vector[1] - bias_vector[0]

            return ForLoop(variable=self._bus_variable_map[variable, bus], start=start, stop=stop, step=step)

        copied_qprogram = deepcopy(self)
        traverse(copied_qprogram.body, copied_qprogram._variables)

        return copied_qprogram

    @overload
    def play(self, bus: str, waveform: Waveform | IQWaveform) -> None:
        """Play a single waveform or an I/Q pair of waveforms on the bus.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (Waveform | IQWaveform): A single waveform or an I/Q pair of waveforms
        """

    @overload
    def play(
        self,
        bus: str,
        waveform: str,
    ) -> None:
        """Play a named waveform on the bus.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (str): An identifier of a named waveform.
        """

    def play(self, bus: str, waveform: Waveform | IQWaveform | str) -> None:
        """Play a waveform, IQWaveform, or calibrated operation on the specified bus.

        This method handles both playing a waveform or IQWaveform, and playing a
        calibrated operation based on the type of the argument provided.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (Waveform | IQWaveform | str): The waveform, IQWaveform, or alias of named waveform to play.
        """
        operation = (
            PlayWithCalibratedWaveform(bus=bus, waveform=waveform)
            if isinstance(waveform, str)
            else Play(bus=bus, waveform=waveform)
        )
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("duration", Domain.Time)
    def wait(self, bus: str, duration: int):
        """Adds a delay on the bus with a specified time.

        Args:
            bus (str): Unique identifier of the bus.
            time (int): Duration of the delay.
        """
        operation = Wait(bus=bus, duration=duration)
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("duration", Domain.Time)
    def wait_trigger(self, bus: str, duration: int, port: int | None = None):
        """Adds a delay on the bus and wait for an trigger signal to arrive.

        Args:
            bus (str): Unique identifier of the bus.
            duration (int): Duration of the delay after the trigger is received. Minimum of 4 ns.
            port (optional, int | None): Port channel of the trigger input. Defaults to None.
        """
        operation = WaitTrigger(bus=bus, duration=duration, port=port)
        self._active_block.append(operation)
        self._buses.add(bus)

    @overload
    def measure(self, bus: str, waveform: IQWaveform, weights: IQWaveform, save_adc: bool = False):
        """Play a pulse and acquire results.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (IQWaveform): Waveform played during measurement.
            weights (IQWaveform): Weights used during demodulation/integration.
            save_adc (bool, optional): If ADC data should be saved. Defaults to False.
        """

    @overload
    def measure(self, bus: str, waveform: str, weights: IQWaveform, save_adc: bool = False):
        """Play a named pulse and acquire results.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (str): Waveform played during measurement.
            weights (IQWaveform): Weights used during demodulation/integration.
            save_adc (bool, optional): If ADC data should be saved. Defaults to False.
        """

    @overload
    def measure(self, bus: str, waveform: IQWaveform, weights: str, save_adc: bool = False):
        """Play a named pulse and acquire results.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (IQWaveform): Waveform played during measurement.
            weights (str): Weights used during demodulation/integration.
            save_adc (bool, optional): If ADC data should be saved. Defaults to False.
        """

    @overload
    def measure(self, bus: str, waveform: str, weights: str, save_adc: bool = False):
        """Play a named pulse and acquire results.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (str): Waveform played during measurement.
            weights (str): Weights used during demodulation/integration.
            save_adc (bool, optional): If ADC data should be saved. Defaults to False.
        """

    def measure(self, bus: str, waveform: IQWaveform | str, weights: IQWaveform | str, save_adc: bool = False):
        """Play a pulse and acquire results.

        Args:
            bus (str): Unique identifier of the bus.
            waveform (IQWaveform): Waveform played during measurement.
            weights (IQWaveform): Weights used during demodulation/integration.
            save_adc (bool, optional): If ADC data should be saved. Defaults to False.
        """
        operation: (
            Measure
            | MeasureWithCalibratedWaveform
            | MeasureWithCalibratedWeights
            | MeasureWithCalibratedWaveformWeights
        )
        if isinstance(waveform, IQWaveform) and isinstance(weights, IQWaveform):
            operation = Measure(bus=bus, waveform=waveform, weights=weights, save_adc=save_adc)
        elif isinstance(waveform, str) and isinstance(weights, IQWaveform):
            operation = MeasureWithCalibratedWaveform(bus=bus, waveform=waveform, weights=weights, save_adc=save_adc)
        elif isinstance(waveform, IQWaveform) and isinstance(weights, str):
            operation = MeasureWithCalibratedWeights(bus=bus, waveform=waveform, weights=weights, save_adc=save_adc)
        elif isinstance(waveform, str) and isinstance(weights, str):
            operation = MeasureWithCalibratedWaveformWeights(
                bus=bus, waveform=waveform, weights=weights, save_adc=save_adc
            )
        self._active_block.append(operation)
        self._buses.add(bus)

    def sync(self, buses: list[str] | None = None):
        """Synchronize operations between buses, so the operations following will start at the same time.

        If no buses are given, then the synchronization will involve all buses present in the QProgram.

        Args:
            buses (list[str], optional): List of unique identifiers of the buses. Defaults to None.
        """
        operation = Sync(buses=buses)
        self._active_block.append(operation)
        if buses:
            self._buses.update(buses)

    def reset_phase(self, bus: str):
        """Reset the absolute phase of the NCO associated with the bus.

        Args:
            bus (str): Unique identifier of the bus.
        """
        operation = ResetPhase(bus=bus)
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("phase", Domain.Phase)
    def set_phase(self, bus: str, phase: float):
        """Set the absolute phase of the NCO associated with the bus.

        Args:
            bus (str): Unique identifier of the bus.
            phase (float): The new absolute phase of the NCO.
        """
        operation = SetPhase(bus=bus, phase=phase)
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("frequency", Domain.Frequency)
    def set_frequency(self, bus: str, frequency: float):
        """Set the frequency of the NCO associated with bus.

        Args:
            bus (str): Unique identifier of the bus.
            frequency (float): The new frequency of the NCO.
        """
        operation = SetFrequency(bus=bus, frequency=frequency)
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("gain", Domain.Voltage)
    def set_gain(self, bus: str, gain: float):
        """Set the gain of the AWG associated with bus.

        Args:
            bus (str): Unique identifier of the bus.
            gain (float): The new gain of the AWG.
        """
        operation = SetGain(bus=bus, gain=gain)
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("offset_path0", Domain.Voltage)
    @requires_domain("offset_path1", Domain.Voltage)
    def set_offset(self, bus: str, offset_path0: float, offset_path1: float | None = None):
        """Set the gain of the AWG associated with bus.

        Args:
            bus (str): Unique identifier of the bus.
            offset_path0 (float): The new offset of the AWG for path0.
            offset_path1 (float): The new offset of the AWG for path1.
        """
        operation = SetOffset(bus=bus, offset_path0=offset_path0, offset_path1=offset_path1)
        self._active_block.append(operation)
        self._buses.add(bus)

    @requires_domain("duration", Domain.Time)
    def set_trigger(self, bus: str, duration: int, outputs: list[int] | int | None = None, position: str = "start"):
        """Set the trigger output for a given instrument.
        Args:
            bus (str): Unique identifier of the bus.
            duration (int): Duration of the trigger pulse. Minimum of 4 ns.
            outputs(optional, list[int] | int | None): Port channel/s of the trigger output. Defaults to None.
            outputs(optional, str): Trigger position in respective to the pulse location, it can be either `start` or `end. Defaults to start.
        """
        operation = SetTrigger(bus=bus, outputs=outputs, duration=duration, position=position)
        self._active_block.append(operation)
        self._buses.add(bus)

    @yaml.register_class
    class _QbloxInterface:
        def __init__(self, qprogram: "QProgram"):
            self.qprogram = qprogram
            self.disable_autosync: bool = False
            self.latch_enabled: list[str] = []
            self.trigger_network_required: dict[str, int] = {}

        @overload
        def acquire(self, bus: str, weights: IQWaveform, save_adc: bool = False):
            """Acquire results based on the given weights.

            Args:
                bus (str): Unique identifier of the bus.
                weights (IQWaveform): Weights used during acquisition.
            """

        @overload
        def acquire(self, bus: str, weights: str, save_adc: bool = False):
            """Acquire results based on the given weights.

            Args:
                bus (str): Unique identifier of the bus.
                weights (str): Weights used during acquisition.
            """

        def acquire(self, bus: str, weights: IQWaveform | str, save_adc: bool = False):
            """Acquire results based on the given weights.

            Args:
                bus (str): Unique identifier of the bus.
                weights (IQWaveform | str): Weights used during acquisition.
            """
            operation = (
                Acquire(bus=bus, weights=weights, save_adc=save_adc)
                if isinstance(weights, IQWaveform)
                else AcquireWithCalibratedWeights(bus=bus, weights=weights, save_adc=save_adc)
            )
            self.qprogram._active_block.append(operation)
            self.qprogram._buses.add(bus)

        @overload
        def play(self, bus: str, waveform: Waveform | IQWaveform, wait_time: int) -> None:
            """Play a single waveform or an I/Q pair of waveforms on the bus.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (Waveform | IQWaveform): A single waveform or an I/Q pair of waveforms
            """

        @overload
        def play(self, bus: str, waveform: str, wait_time: int) -> None:
            """Play a named waveform on the bus.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (str): An identifier of a named waveform.
            """

        def play(self, bus: str, waveform: Waveform | IQWaveform | str, wait_time: int) -> None:
            """Play a waveform, IQWaveform, or calibrated operation on the specified bus.

            This method handles both playing a waveform or IQWaveform, and playing a
            calibrated operation based on the type of the argument provided.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (Waveform | IQWaveform | str): The waveform, IQWaveform, or alias of named waveform to play.
                wait_time (int): Overwrite the value of Q1ASM play instruction's wait_time parameter.
            """
            operation = (
                PlayWithCalibratedWaveform(bus=bus, waveform=waveform, wait_time=wait_time)
                if isinstance(waveform, str)
                else Play(bus=bus, waveform=waveform, wait_time=wait_time)
            )
            self.qprogram._active_block.append(operation)
            self.qprogram._buses.add(bus)

        @overload
        def measure_reset(
            self,
            bus: str,
            waveform: IQWaveform,
            weights: IQWaveform,
            control_bus: str,
            reset_pulse: IQWaveform,
            trigger_address: int = 1,
            save_adc: bool = False,
        ):
            """Play a measurement and conditionally apply a reset pulse based on the result. This enables active reset for transmon qubits.

            If the thresholded measurement result is 1, a corrective pulse is applied on the control_bus.
            If the result is 0, the control_bus waits instead.

            Args:
                bus (str): Identifier of the measurement bus.
                waveform (IQWaveform): Waveform played during measurement.
                weights (IQWaveform): Weights used for demodulation/integration.
                control_bus (str): Identifier of the control/reset bus.
                reset_pulse (IQWaveform): Pulse used for active reset.
                trigger_address (int, optional): Trigger address for synchronization. Defaults to 1.
                save_adc (bool, optional): Whether to save ADC data. Defaults to False.
            """

        @overload
        def measure_reset(
            self,
            bus: str,
            waveform: str,
            weights: str,
            control_bus: str,
            reset_pulse: str,
            trigger_address: int = 1,
            save_adc: bool = False,
        ):
            """Play a measurement and conditionally apply a reset pulse based on the result. This enables active reset for transmon qubits.

            If the thresholded measurement result is 1, a corrective pulse is applied on the control_bus.
            If the result is 0, the control_bus waits instead.

            Args:
                bus (str): Identifier of the measurement bus.
                waveform (str): Waveform played during measurement.
                weights (str): Weights used for demodulation/integration.
                control_bus (str): Identifier of the control/reset bus.
                reset_pulse (str): Pulse used for active reset.
                trigger_address (int, optional): Trigger address for synchronization. Defaults to 1.
                save_adc (bool, optional): Whether to save ADC data. Defaults to False.
            """

        def measure_reset(
            self,
            bus: str,
            waveform: IQWaveform | str,
            weights: IQWaveform | str,
            control_bus: str,
            reset_pulse: IQWaveform | str,
            trigger_address: int = 1,
            save_adc: bool = False,
        ):
            """Play a measurement and conditionally apply a reset pulse based on the result. This enables active reset for transmon qubits.

            If the thresholded measurement result is 1, a corrective pulse is applied on the control_bus.
            If the result is 0, the control_bus waits instead.

            Args:
                bus (str): Identifier of the measurement bus.
                waveform (IQWaveform | str): Waveform played during measurement.
                weights (IQWaveform | str): Weights used for demodulation/integration.
                control_bus (str): Identifier of the control/reset bus.
                reset_pulse (IQWaveform | str): Pulse used for active reset.
                trigger_address (int, optional): Trigger address for synchronization. Defaults to 1.
                save_adc (bool, optional): Whether to save ADC data. Defaults to False.
            """
            operation: MeasureReset | MeasureResetCalibrated
            if (
                isinstance(waveform, IQWaveform)
                and isinstance(weights, IQWaveform)
                and isinstance(reset_pulse, IQWaveform)
            ):
                operation = MeasureReset(
                    bus=bus,
                    waveform=waveform,
                    weights=weights,
                    control_bus=control_bus,
                    reset_pulse=reset_pulse,
                    trigger_address=trigger_address,
                    save_adc=save_adc,
                )
            elif isinstance(waveform, str) and isinstance(weights, str) and isinstance(reset_pulse, str):
                operation = MeasureResetCalibrated(
                    bus=bus,
                    waveform=waveform,
                    weights=weights,
                    control_bus=control_bus,
                    reset_pulse=reset_pulse,
                    trigger_address=trigger_address,
                    save_adc=save_adc,
                )

            #  Raise an error if a calibrated component has been used in conjunction with a non calibrated one
            elif any(isinstance(component, str) for component in (waveform, weights, reset_pulse)):
                raise NotImplementedError(
                    "For the waveform, weight, and reset pulse, you must either use the calibration file for all three or not use it at all."
                )

            self.qprogram._active_block.append(operation)
            self.qprogram._buses.add(bus)
            self.qprogram._buses.add(control_bus)
            self.latch_enabled.append(control_bus)
            self.trigger_network_required[bus] = trigger_address

        def set_markers(self, bus: str, mask: str):
            """Set the markers based on a 4-bit binary mask.

            Args:
                bus (str): Unique identifier of the bus.
                mask (str): A 4-bit mask, where 0 means that the associated marker is open (no signal), and 1 means that the marker is closed (signal).
            """
            operation = SetMarkers(bus=bus, mask=mask)
            self.qprogram._active_block.append(operation)
            self.qprogram._buses.add(bus)

    @yaml.register_class
    class _QuantumMachinesInterface:
        def __init__(self, qprogram: "QProgram"):
            self.qprogram = qprogram

        @overload
        def measure(
            self,
            bus: str,
            waveform: IQWaveform,
            weights: IQWaveform,
            save_adc: bool = False,
            rotation: float = 0.0,
            demodulation: bool = True,
        ):
            """Play a pulse and acquire results.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (IQWaveform): Waveform played during measurement.
                weights (IQWaveform): Weights used during demodulation/integration.
                save_adc (bool, optional): If ADC data should be saved. Defaults to False.
                rotation (float, optional): Angle in radians to rotate the IQ plane during demodulation/integration. Defaults to 0.0
                demodulation (bool, optional): If demodulation is enabled. Defaults to True.
            """

        @overload
        def measure(
            self,
            bus: str,
            waveform: str,
            weights: IQWaveform,
            save_adc: bool = False,
            rotation: float = 0.0,
            demodulation: bool = True,
        ):
            """Play a named pulse and acquire results.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (str): Waveform played during measurement.
                weights (IQWaveform): Weights used during demodulation/integration.
                save_adc (bool, optional): If ADC data should be saved. Defaults to False.
                rotation (float, optional): Angle in radians to rotate the IQ plane during demodulation/integration. Defaults to 0.0
                demodulation (bool, optional): If demodulation is enabled. Defaults to True.
            """

        @overload
        def measure(
            self,
            bus: str,
            waveform: IQWaveform,
            weights: str,
            save_adc: bool = False,
            rotation: float = 0.0,
            demodulation: bool = True,
        ):
            """Play a named pulse and acquire results.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (IQWaveform): Waveform played during measurement.
                weights (str): Weights used during demodulation/integration.
                save_adc (bool, optional): If ADC data should be saved. Defaults to False.
                rotation (float, optional): Angle in radians to rotate the IQ plane during demodulation/integration. Defaults to 0.0
                demodulation (bool, optional): If demodulation is enabled. Defaults to True.
            """

        @overload
        def measure(
            self,
            bus: str,
            waveform: str,
            weights: str,
            save_adc: bool = False,
            rotation: float = 0.0,
            demodulation: bool = True,
        ):
            """Play a named pulse and acquire results.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (str): Waveform played during measurement.
                weights (str): Weights used during demodulation/integration.
                save_adc (bool, optional): If ADC data should be saved. Defaults to False.
                rotation (float, optional): Angle in radians to rotate the IQ plane during demodulation/integration. Defaults to 0.0
                demodulation (bool, optional): If demodulation is enabled. Defaults to True.
            """

        def measure(
            self,
            bus: str,
            waveform: IQWaveform | str,
            weights: IQWaveform | str,
            save_adc: bool = False,
            rotation: float = 0.0,
            demodulation: bool = True,
        ):
            """Play a pulse and acquire results.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (IQWaveform): Waveform played during measurement.
                weights (IQWaveform): Weights used during demodulation/integration.
                save_adc (bool, optional): If raw ADC data should be saved. Defaults to False.
                rotation (float, optional): Angle in radians to rotate the IQ plane during demodulation/integration. Defaults to 0.0
                demodulation (bool, optional): If demodulation is enabled. Defaults to True.
            """
            operation: (
                Measure
                | MeasureWithCalibratedWaveform
                | MeasureWithCalibratedWeights
                | MeasureWithCalibratedWaveformWeights
            )
            if isinstance(waveform, IQWaveform) and isinstance(weights, IQWaveform):
                operation = Measure(
                    bus=bus,
                    waveform=waveform,
                    weights=weights,
                    save_adc=save_adc,
                    rotation=rotation,
                    demodulation=demodulation,
                )
            elif isinstance(waveform, str) and isinstance(weights, IQWaveform):
                operation = MeasureWithCalibratedWaveform(
                    bus=bus,
                    waveform=waveform,
                    weights=weights,
                    save_adc=save_adc,
                    rotation=rotation,
                    demodulation=demodulation,
                )
            elif isinstance(waveform, IQWaveform) and isinstance(weights, str):
                operation = MeasureWithCalibratedWeights(
                    bus=bus,
                    waveform=waveform,
                    weights=weights,
                    save_adc=save_adc,
                    rotation=rotation,
                    demodulation=demodulation,
                )
            elif isinstance(waveform, str) and isinstance(weights, str):
                operation = MeasureWithCalibratedWaveformWeights(
                    bus=bus,
                    waveform=waveform,
                    weights=weights,
                    save_adc=save_adc,
                    rotation=rotation,
                    demodulation=demodulation,
                )
            self.qprogram._active_block.append(operation)
            self.qprogram._buses.add(bus)

    @yaml.register_class
    class _QdacInterface:
        def __init__(self, qprogram: "QProgram"):
            self.qprogram = qprogram

        @overload
        def play(
            self,
            bus: str,
            waveform: Waveform | IQWaveform,
            dwell: int | None = None,
            delay: int | None = None,
            repetitions: int | None = None,
            stepped: bool | None = None,
        ) -> None:
            """Play a single waveform or an I/Q pair of waveforms on the bus.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (Waveform | IQWaveform): A single waveform or an I/Q pair of waveforms
                dwell (int | None, optional): Resolution un us of the QDACII pulse with a minimum of 2 us. Defaults to 2 inside QDACII compiler.
                delay (int | None, optional): Delay of the QDACII pulse. Defaults to 0 inside QDACII compiler.
                repetitions (int | None, optional): Number of pulse repetitions. Defaults to the default repetitions inside QDACII compiler.
                stepped (bool | None, optional): Defining if the ramp will have a stair shape. Defaults to False.
            """

        @overload
        def play(
            self,
            bus: str,
            waveform: str,
            dwell: int | None = None,
            delay: int | None = None,
            repetitions: int | None = None,
            stepped: bool | None = None,
        ) -> None:
            """Play a named waveform on the bus.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (str): An identifier of a named waveform.
                dwell (int | None, optional): Resolution un us of the QDACII pulse with a minimum of 2 us. Defaults to 2 inside QDACII compiler.
                delay (int | None, optional): Delay of the QDACII pulse. Defaults to 0 inside QDACII compiler.
                repetitions (int | None, optional): Number of pulse repetitions. Defaults to the default repetitions inside QDACII compiler.
                stepped (bool | None, optional): Defining if the ramp will have a stair shape. Defaults to False.
            """

        def play(
            self,
            bus: str,
            waveform: Waveform | IQWaveform | str,
            dwell: int | None = None,
            delay: int | None = None,
            repetitions: int | None = None,
            stepped: bool | None = None,
        ) -> None:
            """Play a waveform, IQWaveform, or calibrated operation on the specified bus.

            This method handles both playing a waveform or IQWaveform, and playing a
            calibrated operation based on the type of the argument provided.

            Args:
                bus (str): Unique identifier of the bus.
                waveform (Waveform | IQWaveform | str): The waveform, IQWaveform, or alias of named waveform to play.
                dwell (int | None, optional): Resolution un us of the QDACII pulse with a minimum of 2 us. Defaults to 2 inside QDACII compiler.
                delay (int | None, optional): Delay of the QDACII pulse. Defaults to 0 inside QDACII compiler.
                repetitions (int | None, optional): Number of pulse repetitions. Defaults to the default repetitions inside QDACII compiler.
                stepped (bool | None, optional): Defining if the ramp will have a stair shape. Defaults to False inside QDACII compiler.
            """

            operation = (
                PlayWithCalibratedWaveform(
                    bus=bus, waveform=waveform, dwell=dwell, delay=delay, repetitions=repetitions, stepped=stepped
                )
                if isinstance(waveform, str)
                else Play(
                    bus=bus, waveform=waveform, dwell=dwell, delay=delay, repetitions=repetitions, stepped=stepped
                )
            )
            self.qprogram._active_block.append(operation)
            self.qprogram._buses.add(bus)

    def draw(
        self,
        time_window: int | None = None,
        averages_displayed: bool = False,
        acquisition_showing: bool = True,
        calibration: Calibration | None = None,
    ):
        """Draw the QProgram using QBlox Compiler

        Args:
            time_window (int): Allows the user to stop the plotting after the specified number of ns have been plotted. The plotting might not be the precise number of ns inputted.
                For example, if the timeout is 100 ns but there is a play operation of 150 ns, the plot will display the data until 150 ns. Defaults to None.
            averages_displayed (bool): False means that all loops on the sequencer starting with avg will only loop once, and True shows all iterations. Defaults to False.
            acquisition_showing (bool): Allows visualing the acquisition period on the plot. Defaults to True.

        Returns:
            plotly object: plotly.graph_objs._figure.Figure
        """

        from qililab.instruments.qblox.qblox_draw import QbloxDraw
        from qililab.qprogram.qblox_compiler import QbloxCompiler

        qblox_draw = QbloxDraw()
        compiler = QbloxCompiler()
        sequencer = compiler.compile(qprogram=self, calibration=calibration)
        plotly_figure, _ = qblox_draw.draw(
            sequencer=sequencer,
            time_window=time_window,
            averages_displayed=averages_displayed,
            acquisition_showing=acquisition_showing,
        )
        return plotly_figure
