@startuml

participant CircuitToPulses as trans
participant HardwareGateFactory as fact
participant PlatformSettings as set
participant GateSettings as gateset
participant Chip as chip

[-> trans ++: control_gate_to_pulse (time, control_gate, chip)
trans -> trans: get_gate_settings_with_master_values (control_gate)
activate trans #7F1CDB
trans -> set ++: get_master_amplitude_gate ()
return master_amplitude_gate
trans -> set ++: get_master_duration_gate ()
return master_duration_gate
trans -> fact ++: gate_settings (control_gate, master_amplitude_gate, master_duration_gate)
loop pulsed_gate in cls.pulsed_gates.values ()
    opt isinstance (control_gate, pulsed_gate.class_type)
        fact -> gateset ++: translate (control_gate, master_amplitude_gate, master_duration_gate)
        note right of gateset #E68AA3: GateSettings translate
        return gate_settings
        note right of fact: break
    end
end
return gate_settings
return gate_settings

trans -> trans: build_pulse_shape_from_gate_settings (gate_settings)
activate trans #7F1CDB
trans -> gateset ++: copy_shape ()
return shape_settings
alt pulse_shape_name is DRAG
    trans -> set ++: get_master_beta_pulse_shape ()
    return master_beta_pulse_shape
    note right of trans: pulse_shape = Factory.get(name)(shape_settings, master_beta_pulse_shape)
else
    note right of trans: pulse_shape = Factory.get(name)(shape_settings)
end
return pulse_shape

trans -> chip ++: get_port_from_qubit_idx (idx = control_gate.target_qubits[0], False)
note right of chip #C2A5DC: Chip get_port_from_qubit_idx
return port

trans -> gateset ++: get_duration ()
return duration

trans -> set ++:get_delay_between_pulses ()
return delay_between_pulses

trans -> trans: update_time (time, chip, port, pulse_time = duration + delay_between_pulses)
activate trans #7F1CDB
trans -> chip ++: get_qubit_idx_from_node (port)
note right of chip #C2A5DC: Chip get_qubit_idx_from_node
return qubit_idx

opt qubit_idx not in time
    note right of trans: time[qubit_idx] = 0
end
note right of trans: old_time = time[qubit_idx]
note right of trans: time[qubit_idx] += pulse_time
return old_time

alt gate_settings.duration > 0
    trans -> Pulse **: Pulse (gate_settings.amplitude, gate_settings.phase, gate_settings.duration, pulse_shape, old_time)
    activate Pulse
    return result_pulse
else
    note right of trans: result_pulse = None
end

return (result_pulse, port.id)

@enduml