@startuml

participant SimulatedSystemControl as sim
participant SimulatedSystemControlSettings as simset
participant PulseSequence as pulseseq
participant Waveforms as waveforms
participant Pulse as pulse
participant PulseShape as pulseshape
participant SimulatorResult as simres
queue Qutip as qutip

[-> sim ++: run (pulse_sequence, nshots, repetition_duration, path)
sim -> simset ++: get_resolution ()
return resolution
sim -> pulseseq ++: waveforms (self.awg_frequency, resolution)
note right of pulseseq #C2A5DC: PulseSequence waveforms
return waveforms

note right of sim: i_waveform = waveforms.i * self.amplitude_norm_factor
sim -> simset ++: get_qubit ()
return qubit
sim -> simset ++: get_dimension ()
return dimension
sim -> simset ++: get_resolution ()
return resolution
sim -> simset ++: create_hamiltonian (qubit, i_waveform, dimension, self.energy_norm, resolution)
return hamiltonian
sim -> qutip ++: hamiltonian.to_qutip ()
return hami, tlist
sim -> qutip ++: hami[0].eigenstates()
return eigen_states
sim -> qutip ++: qutip.ket2dm(eigen_states[0])
return init0
sim -> qutip ++: qutip.ket2dm(eigen_states[1])
return init1
sim -> qutip ++: qutip.mesolve(hami, init0, tlist, self.options, [init0, init1])
return results
sim -> simres **: SimulatorResult (results.expect[0][-1], results.expect [1][-1])
activate simres
return simulator_result
return simulator_result

@enduml